---
title: History of Loongson | How long is the way of Loongson
categories:
  - history
tags:
  - chip
  - cpu
  - architecture
  - history
---
# 前言
最近几年系统性的学习并梳理了近30多年的计算技术发展历史，稍有感悟。遂决定将之整理成文，目的有二，一来作为知识沉淀，串联起不同技术，挖掘不同架构之间的渊源，二来通过整理再次审视历史，期望窥见未来发展方向。我将本系列命名为**鉴往知远**, 主要关注**计算与互联**。 本文为第二篇，主要回顾**龙芯**系列。
# 0. 概述
**龙芯**根据架构的不同，存在 3 个处理器系列。
- **龙芯一号**，用于消费电子和嵌入式应用
- **龙芯二号**，用于嵌入式应用和低性能个人计算机的单核处理器
- **龙芯三号**，用于更高性能计算机、高性能计算和服务器的多核处理器

龙芯处理器核按照微架构，分为四类，分别是：
* **单发射32位（132）GS132**：带硬件分频器的基本嵌入式 MIPS32 内核。3- (*GS132*) 或 5- (*GS132E*) 级流水线
* **双发射32位（232）GS232**：高端嵌入式 MIPS32
	* *GS232* 最多有 5 级流水线，500MHz，16KB L1。*GS232* 主要用于龙芯一号产品
	* *GS232E*最多有 10 级流水线，1000 MHz，16KB L1，L2 = 4 MB 共享。乱序执行
* **四发射64位（464） GS464**：具有四路超标量乱序执行的MIPS64内核。该设计起源于龙芯2F处理器
	- *GS464* 支持 MIPS64 R2 + LoongMMI（2E 和 2F 中的两个不同版本）
	- *GS464V* 于 2010 年随**龙芯3B** 首次推出，是具有矢量功能的 *GS464*
	- *GS464E*是 *GS464* 的改进版本，包括更大的缓存和更好的分支预测等
	- *GS464EV* 是 *GS464* 系列的发展，首先被 **3A4000** 处理器使用
* **双发射64位（264）GS264**：MIPS64 内核，是*GS232*的64位实现

另外，*LA464* 是 *GS464*的发展，支持 LoongArch。下图展示了**龙芯**各代产品之间继承和发展关系图：
![Pasted image 20231019150554.png](/assets/images/godson/Pasted image 20231019150554.png)
* **龙芯 1** 即**Godson-1**是单发射乱序32位处理器，是中国国内设计的第一个通用处理器
* **龙芯 2** 是 MIPS III 兼容 64 位处理器系列。与龙芯 3 系列共享 GS464处理器核，**龙芯 2**的发展规划是从CPU发展为SOC。龙芯 2E (2006) 是一个 CPU，2F (2007) 集成了北桥。2F 的设计是 *GS464* 核心的基础
* 2009年的**龙芯 3A1000**是第一个生产的处理器，使用 4 个 *GS464* 内核，65 nm工艺。 **龙芯 3A1000** 能够以接近 1 GHz的时钟速度运行，首先是4 个 CPU 内核（~15 W），然后是 8 个内核（40 W）的**龙芯3B1500**
* 2015 年，发布了 **龙芯3A1500** 和 **龙芯3B2000**。使用增强型 *GS464E* 处理器核，改进后的微体系结构提供了更好的性能，据报道速度是 **龙芯3A1000** 的 3 倍，并且还引入了 *LoongISA 增强型指令集*。 **龙芯3A1500** 用于嵌入式应用，而 **龙芯3B2000** 用于服务器和 PC
* 2017年**龙芯**发布**龙芯3A3000**。**龙芯3A3000** 采用四核 64 位设计，主频为 1.5 GHz，功耗仅为 30 W
* 2019 年底，发布了 **龙芯3A 4000** 和 **龙芯3B 4000** 系列。使用了升级后的 *GS464EV* 微架构。处理器设计有四个内核，8MB 的 L3 缓存和 1.8 GHz 至 2 GHz 之间的工作时钟
* 2021年7月，**龙芯3 5000**系列发布。该系列处理器是龙芯首款自主研发的**LoongArch**指令集架构，包括 **龙芯3A5000**，一个四核台式机 CPU 和 **3C5000L**，一个十六核服务器 CPU，基于单个封装中的四个 3A5000。使用*LA464*处理器核
* 2023年8月，**龙芯**官方有报道**龙芯3A6000**相关性能数据，但暂未发布，据传使用是6发射的*LA664*处理器核

本文主要关注**龙芯三号**，其微架构主要为四发射64位，即*GS464*系列。关于**龙芯**指令集架构历史渊源请参考第一章**龙芯**指令集架构的介绍。本文通过系统性回顾整个**龙芯**系列处理器，试图通过**龙芯**系列处理器发展的历史脉络，来展现国内处理器技术发展历程，以及和国际主流处理器厂商的差异。下表总结了各代处理器之间的关键指标和规格：

|   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
||Godson-1|Godson-2B|Godson-2C|Godson-2E|Loongson 2F|Loongson 2G|Loongson 3A1000|Loongson 3B1500|Loongson 3A2000|Loongson 3A3000|Loongson 3A4000|Loongson 3A5000|Loongson 3A6000|
|Date|2001|2003|2004|2006|2008|2010|2009|2015|2015|2016|2019|2021|2023|
|Core Name|GS132|NA|NA|GS464r1|GS464r1|GS464r2|GS464r2|GS464V|GS464E|GS464E|GS464EV|GS464V/LA464|LA664|
|Technology|0.18um|0.18um|0.18um|90nm|ST 90nm|ST 65nm|ST 65nm|SMIC 32nm|SMIC 40nm|ST 28nm|ST 28nm|12nm|12nm|
|Transistors|4M|15M|15M|47M|51M|100M|425M|1.14B|8B|8B||||
|Area(mm^2)|NA|41.5|41.5|36|43|54|140|182.5|248.6(17.66x14.08)|248.6(25.3x28.8)|232|147||
|TDP(W)|0.5|NA|NA|5-7|3-5|3|15|30-60|15|40|50|35||
|Frequency(GHz)|0.266|0.25|0.45|1|0.8|1|0.8-1|1.5|0.8-1|1.2-1.5|1.8|2.3-2.5|2.5|
|No. Inst Decode|1|4|4|4|4|4|4|4|4|4|4|4|4|
|No. Inst Issue|1|4|4|4|4|4|4|4|4|4|4|4|6|
|COREs|1|1|1|1|1|1|4|8|4|4|4|4|8|
|Threads|ST|ST|ST|ST|ST|ST|ST|ST|ST|ST|ST|ST|SMT2|
|L1 Cache|I$: 8K 2 way  <br>D$: 8K 4 way|I$: 64K 4 way  <br>D$: 64K 4 way|I$: 64K 4 way  <br>D$: 64K 4 way|I$: 64K 4 way  <br>D$: 64K 4 way|I$: 64K 4 way  <br>D$: 64K 4 way|I$: 64K 4 way  <br>D$: 64K 4 way|I$: 64K 4 way  <br>D$: 64K 4 way|I$: 64K 4 way  <br>D$: 64K 4 way|I$: 64K 4 way  <br>D$: 64K 4 way|I$: 64K 4 way  <br>D$: 64K 4 way|I$: 64K 4 way  <br>D$: 64K 4 way|I$: 64K 4 way  <br>D$: 64K 4 way|I$: 64K 4 way  <br>D$: 64K 4 way|
|L2 Cache|NA|8MB offchip|8MB offchip|512K 4 way|512K 4 way|1M 4 way|4M 8 way|128K/Core|256K/Core 16 way|256K/Core|256K/Core|256K/Core 16 way|256K/Core|
|L3 Cache|NA|NA|NA|NA|NA|NA|NA|8M|4M 16 way|8M 16 way|8M 16 way|16M 16 way|16M|
|IO|PCI|PCI|PCI|PCI|PCI|PCI|HT 1.0 2x8@800MHz|HT 2.0 2x16@3.2GHz|HT 2x16@3.2GHz|HT 2x16@3.2GHz|HT 2x16@3.2GHz|HT 2x16@3.2GHz|HT 2x16@3.2GHz|
|Memory|8-256M|128bit 64M-2G|DDR|DDR2|DDR2-333|DDR2/3|DDR2/3|DDR2-800/3-1200 2x72|DDR2-800/3-1333 2x72|DDR2-800/3-1600 2x72|DDR4-2400 2x72|DDR4-3200 2x72|DDR4-3200 2x72|
|Comments|MIPS-III 32|MIPS-III 64|MIPS-III 64|MIPS-III 64|MIPS-III 64|MIPS64|MIPS64|LoongISA 1.0|LoongISA 1.0|LoongISA 1.0|LoongISA 2.0|LoongISA 2.0||


可以发现，**龙芯**处理器很多精力都花在指令集上了，而本身处理器核的微架构更新比较缓慢。另外，根据网络上公开信息，从 **龙芯2F** 到 **龙芯3A1000** ，包括**龙芯3B1500**，访存性能严重低于理论值，导致性能问题。

本文组织形式如下:
* 第一章简单介绍**龙芯**指令集架构**LoongArch v1.02**
* 第二章介绍**Godson-1**的微架构，了解**龙芯**乃至中国的第一个处理器设计
* 第三章介绍**Godson-2**和**Godson-3A**的处理器核*GS464*微架构，后续**龙芯**都是以*GS464*为基础
* 第四章简单描述**Loongson-3B1500** 整体架构以及支持向量运算的处理器核*GS464V*微架构
* 第五章介绍**Loongson-3A2000**的处理器核*GS464E*的微架构
* 第六章简单介绍基于*GS464E*的**Loongson-3A3000**，主要是基于**Loongson-3A2000**做了工艺升级
* 第七章简单介绍基于*GS464EV*的**Loongson-3A4000**，
* 第八章介绍基于*LA464*处理器核的**Loongson-3A5000**
* 第九章预留给**Loongson-3A6000**，待产品发布之后更新
* 文章最后列出了主要的参考文献

# 1. LoongArch指令集架构
龙芯的指令集架构分为三个阶段：
1. **MIPS** 龙芯在初始阶段使用MIPS64 指令集架构(ISA)。2009 年 6 月，ICT 直接从MIPS公司获得了 MIPS32 和 MIPS64 架构的许可。2011 年 8 月，龙芯科技有限公司从 MIPS 公司获得 MIPS32 和 MIPS64 架构许可，用于继续开发基于 MIPS 的龙芯 CPU 内核
2. **LoongISA** 2015年**龙芯3A2000**采用*LoongISA 1.0*扩展指令集，是 MIPS64 的超集。*LoongISA* 指令作为 *GS464E* 内核的一部分引入。包括下列部分：
	- LoongEXT，通用扩展，148 条指令
	- LoongVZ，MIPS64 版本 5 中引入的“VZ”系统的虚拟化扩展，5 条指令
	- LoongBT，更快的 x86 和ARM二进制翻译，213 条指令
	- LoongSIMD，原名LoongMMI（在龙芯2E/F），为128位SIMD，1014条指令
	- 来自 MIPS 第 5 版的 MIPS SIMD 架构 (MSA)、DSP 和 VZ 模块

3. **LoongArch** 随着**龙芯 3 5000** 系列的发布，**龙芯**在 2021 年转向了自己的处理器指令集架构(ISA)。*LoongArch* 包括一个简化的 32 位版本（LA32R），一个标准的 32位版本 (LA32S) 和 64 位版本 (LA64)。

*LoongArch ISA* 手册已于 2021 年 8 月部分可用，其第一卷记录了基本架构。根据LoongArch手册，ISA使用了MIPS的特权模型和IRQ机制，其他部分大多遵循RISC-V的做法：去掉了分支延迟槽，改变了指令编码。*LoongArch* 是全新的指令集，不是在 MIPS 上做的扩展。包含基础指令 337 条、虚拟机扩展 10条 、二进制翻译扩展176 条、128 位向量扩展 1024 条、256 位向量扩展 1018 条，共计 2565 条原生指令。相对于MIPS，摒弃了部分不适合现代CPU的指令，又做了大量改进和扩展。例如单条指令支持的立即数从MIPS的最大16位扩展到最大24位，分支跳转偏移也从64K扩展到1M字节，以及寻址空间从固定分段改变为单一平面等，都有效减少了编译结果的目标指令条数和访存次数，提高了效能。LoongArch的指令系统在设计时，以先进性、扩展性、兼容性为目标，其中兼容性是指融合MIPS/x86/ARM指令系统的主要特点，高效支持二进制翻译。

## 1.1 寄存器
*LoongArch* 为RISC指令集，有32个通用寄存器、32个浮点/向量寄存器。其中*r0*的值为0，*PC*的值是当前指令地址，只能被转移指令，异常陷入和异常返回间接修改。寄存器宽度在LA32下是32比特，在LA64下是64比特。

![Pasted image 20231018134609.png](/assets/images/godson/Pasted image 20231018134609.png)

## 1.2 计算模式
龙芯架构分为LA32和LA64两种计算模式，LA64可以兼容LA32的应用层软件，具体由`CSR.MISC.VA32L1/VA32L2/VA32L3`控制，当这些值为1时，运行在PLV1/PLV2/PLV3级下的软件就以32位地址模式运行。此时硬件将访存虚拟地址低32位零扩展至64位之后的值作为访存的地址。

## 1.3 指令格式
MIPS只有3种指令格式，*LoongArch*重新设计了指令格式 ，使用32位定长指令，可用的格式多达9种 ，其包含3种无立即数格式和6种有立即数格式。重新设计的指令格式可以包含更多的指令槽，有利于以后的长远发展。指令编码格式如下表所示：
![Pasted image 20231018134157.png](/assets/images/godson/Pasted image 20231018134157.png)
## 1.4 特权模型
龙芯架构分为4个特权等级，分别是*PLV0~PLV3*，由*CSR.CRMD.PLV* 确定。其中，*PLV0*具有最高特权等级，可以使用特权指令并访问所有特权资源。*PLV1~PLV3*，都不能执行特权指令和访问特权资源，在MMU采用映射地址翻译模式下具有不同的访问权限。

## 1.5 存储模型
龙芯架构的存储一致性模型采用弱一致性(Weakly Consistency)模型，程序必须使用同步指令对写共享单元的访问保护起来，以保证对于写共享单元的访问是互斥的。对访存的顺序限制如下：
1. 同步指令的执行满足顺序一致性条件，即同步操作在所有处理器核中都严格按照程序顺序执行，在当前同步指令完成之前不能开始执行下一个同步操作
2. 在任一访存指令被执行之前，该指令之前的同步指令已经完成
3. 在任一同步指令被执行之前，该指令之前的访存指令都已完成

龙芯架构下支持三种存储访问类型，由页表中*MAT(Memory Access Type)* 决定，分别是:
* **一致可缓存(Coherent Cached)** 访问对象可以是主存也可以是缓存
* **强序非缓存(Strongly-ordered UnCached)** 严格按照程序顺序执行
* **弱序非缓存(Weakly-ordered UnCached)** 读允许投机执行，写可以合并

## 1.6 内存管理及虚拟化
龙芯架构MMU地址翻译由`CSR.CRMD`控制，
* 当`CSR.CRMD.DA=1 && CSR.CRMD.PG=0`时，虚拟地址就是物理地址
* 当`CSR.CRMD.DA=0 && CSR.CRMD.PG=1`时，虚拟地址需要经过翻译，可以分为直接映射和页表映射

### 1.6.1 直接映射地址翻译模式
软件通过设置`CSR.DMW0~CSR.DMW3`寄存器来分别设置四个直接映射配置窗口，前两个同时用于取指和存储加载指令，后两个只作用于存储加载指令。
在LA64架构下，当虚拟地址最高4位[63:60]与配置窗口寄存器中的`VSEG`域相等且特权等级匹配时，物理地址等于虚拟地址的[PALEN-1:0]。
在LA32架构下，每一个直接映射配置窗口寄存器可以配置一个$2^{29}$字节固定大小的虚拟地址空间，当虚拟地址的最高3位[31:29]与配置窗口寄存器中的[31:29]相等且特权等级匹配时，物理地址等于虚拟地址[28:0]拼接上映射配置寄存器配置的物理地址高位。

### 1.6.2 页表映射
龙芯架构下TLB的重填以及TLB与内存页表的一致性维护全部需要软件完成，多级页表结构如下所示：
![Pasted image 20231018195837.png](/assets/images/godson/Pasted image 20231018195837.png)
当遍历页表时，PGD由虚拟地址$PALEN-1$决定，
* 当VA[PALEN-1]=0时，PGD来自`CSR.PGDL`
* 当VA[PALEN-1]=1时，PGD来自`CSR.PGDH`

页表项格式如下表所示：
![Pasted image 20231018202258.png](/assets/images/godson/Pasted image 20231018202258.png)

## 1.7 异常和中断
异常和中断会打断当前正在执行的应用程序，并切换到异常中断处理程序入口开始执行，异常和中断属于架构中特权资源处理部分，下面主要介绍常用一些异常：
* **系统调用异常** 执行`SYSCALL` 指令触发
* **断点异常** 执行`BREAK`指令触发
* **指令不存在异常** 所执行的指令编码未定义时触发
* **特权指令错异常** 在非特权模式下执行特权指令时触发
* **地址错异常** 当取指或访存指令的地址出现分发情况时，分别会触发取指指令地址错异常或访存指令地址错异常
* **浮点错异常** 当浮点指令的数据出现异常情况需要特殊处理时触发

### 1.7.1 异常和中断处理
TLB重填异常的入口地址是`CSR.TLBRENTRY`, 机器错误异常的入口是`CSR.MERRENTRY`，其他异常称为普通异常，入口地址等于$入口页号 | 页内偏移$ ，所有普通异常的入口页号都是`CSR.EENTRY` ；而页内偏移由中断偏移模式和异常号(ecode)共同决定，等于$2^{CSR.ECFG.VS+2} * (ecode+64)$ 。中断被当成普通异常处理，因此使用普通异常的入口计算方式，区别是，中断对应的异常号是对应中断号加上64。异常`ecode`如下表所示：
![Pasted image 20231018221820.png](/assets/images/godson/Pasted image 20231018221820.png)
触发异常的指令的地址会被记录到`ERA`里，作为异常返回地址；对于地址错误相关的异常，出错的地址会被记录到`BADV`。触发异常的指令会被记录到`BADI`里。

# 2. Godson-1
**龙芯**第一款处理器**龙芯1号**设计于2001年，2002年发布，是一款32位单发射乱序执行CPU，主频266MHz。学术论文上代号是*Godson-1*，是中国科学院知识创新工程方向性项目与国家“八六三”高技术研究发展计划项目的研究成果。它采用 0.18 微米 CMOS 工艺制造，具有 8 KB L1D、8 KB L1I 和一个 64 位浮点单元，能够达到 200 双精度 MFLOPS。下图展示了*Godson-1*的物理规划版图：
![Pasted image 20231019213439.png](/assets/images/godson/Pasted image 20231019213439.png)

**龙芯1号**实现基于操作队列复用的寄存器重命名技术，采用*Tomasulo*算法进行动态调度，分支预测使用静态预测，即每次都预测分支执行。主要由取值单元，译码单元，操作队列，定点和浮点寄存器文件和定点浮点执行单元组成。下图展示了*Godson-1*的微架构：
![Pasted image 20231019213259.png](/assets/images/godson/Pasted image 20231019213259.png)
指令译码单元按程序顺序将译码后指令分发到操作队列，操作队列根据指令类型发射到对应的保留站，并按序结束已经完成的指令。保留站中的指令经过执行单元之后，结果写回到操作队列和结果总线。如果指令发射时源操作数还没有准备好，并不会阻止指令的发射，而是通过操作队列号建立指令间的数据依赖关系并发射到保留站；保留站自动侦听总线结果并接受所需要的值，具体过程如下：
1. 指令进入操作队列时将该指令的的源寄存器号与操作队列中的每一个指令的目标寄存器号进行比较，得到操作队列中最近的写该寄存器的指令的位置`Qid`
2. 指令发射时检查`Qid`的值，如果已经写回到操作队列则直接读出，否则将`Qid`送到保留站并记录值未准备好
3. 当保留站中所有操作数都准备好后开始运算并把结果送到结果总线，对应操作队列和保留站

指令流水线分成取值，译码，重命名，发射，执行，写回，完成等阶段，其中执行阶段可能需要多拍，具体如下：
* **取值** 根据当前程序计数器`PC`将指令从缓存读到指令寄存器`IR`，无分支指令及异常情况下，下一条指令的`PC`为当前指令的`PC`+4
* **译码** 根据`IR`中的指令进行译码并写入操作队列，如果操作队列已满，流水线暂停
* **重命名** 该指令的的源寄存器号与操作队列中的每一个指令的目标寄存器号进行比较，得到操作队列中最近的写该寄存器的指令的位置`Qid`
* **发射** 从操作队列中选出一个指令并发射到相应的保留站，如果指令源操作数不可用，则需要保留站记录值未准备好
* **执行** 执行单元从保留站中取出所有源操作数都准备好的指令进行运算，并将结果及指令在操作队列位置编号送到结果寄存器
* **写回** 把结果寄存器的值以及相应指令在操作队列位置编号送到结果总线，保留站和操作队列侦听结果总线的信息，并更新相应状态
* **结束** 如果操作队列中的第一个指令已经完成，则结束该指令并将操作队列里的结果写回到目标寄存器。如果操作队列中的第一个指令在执行过程中发生异常，则进行异常处理

# 3. Godson-2 和 Godson-3
**龙芯2F**于2007年7月31日流片成功，90纳米工艺，4发射乱序执行，面积 $43mm^2$ ，**龙芯2F**是**龙芯**第一款成功的商用处理器。下图展示了*Godson-2E*的物理规划图：
![Pasted image 20230726155408.png](/assets/images/godson/Pasted image 20230726155408.png)
下图展示了*Godson-2F*的物理规划图：
![Pasted image 20230726155505.png](/assets/images/godson/Pasted image 20230726155505.png)

**龙芯2G**是在“龙芯安全适用计算机CPU研制与应用”核高基重大专项课题支持下研发的，2008年开始投入设计，2010年研制成功。**龙芯2G**采用65纳米工艺，主频1.0GHz，晶体管数目1亿，指令集兼容MIPS64，且增加了X86二进制翻译加速指令，以及龙芯媒体扩展指令，有64KB的指令和64KB数据的L1缓存，以及1MB的L2缓存，功耗3W。在该处理器上，使用了X86二进制翻译技术，提出了在MIPS平台上实现X86动态二进制翻译的方法。龙芯2G相当于**龙芯3A1000**的单核版本。**龙芯3A1000**于2008年底交付流片,采用意法半导体的65nm工艺流片，主频800MHz-1GHz。**龙芯3A1000**进行了第一次改版并于2010年5月中旬流片，10月底第一次改版流片成功。**3A1000**的第二次改版于2012年2月下旬流片，2012年8月中旬流片成功。

**龙芯3A1000**集成了4个四发射乱序执行的*GS464*核，9级流水线，有64KB一级数据缓存和64KB一级指令缓存，4MB共享二级缓存，最高主频1GHz，功耗15w（支持动态降频），芯片面积 $174mm^2$ ，晶体管数目4.25亿。每个CPU核包含两个浮点乘加部件，双精度浮点性能峰值为16GFlops。在**龙芯3A1000**处理器中，实现了x86二进制翻译加速指令。**3A1000**集成了PCI控制器、LPC、SPI、UART、GPIO和2个HT1.0；集成72位DDR2/3控制器。下图展示了*Godson-3A1000*的物理规划版图：
![Pasted image 20230726160528.png](/assets/images/godson/Pasted image 20230726160528.png)
**龙芯3A1000**第一级互联采用6x6的交叉开关，用于4个处理器核，4个共享缓存模块和两个IO端口的连接。第二级互联采用5x3的交叉开关，连接4个共享的缓存模块，两个内存控制器和一个IO端口。下图展示了**龙芯3A1000**整体架构：
![Pasted image 20231020182251.png](/assets/images/godson/Pasted image 20231020182251.png)
下图展示了一个8x8交叉互联的架构：
![Pasted image 20231020181812.png](/assets/images/godson/Pasted image 20231020181812.png)
8个*AXI master link(AML)* 和 8个*AXI slave link(ASL)* 通过一个交叉开关进行互联，*AML* 使用读写请求的地址信息进行路由，读写各有8个地址区间，对应*ASL*。*ASL*通过相应请求的*AML* 端口号将读写响应路由到对应的*AML*。*AML*和*ASL*各有两级流水，所以交叉互联一共有4个周期延迟。

## 3.1 GS464微架构
下图展示了*GS464*的微架构：
![Pasted image 20231020181006.png](/assets/images/godson/Pasted image 20231020181006.png)
指令流水线分成取值，译码，重命名，发射，执行，写回，完成等阶段，其中执行阶段可能需要多拍，具体如下：
* **取值** 根据当前程序计数器`PC`将指令从缓存读到指令寄存器`IR`，无分支指令及异常情况下，下一条指令的`PC`为当前指令的`PC`+16
* **预译码** 对指令扫描，识别出分支指令并对其分支方向进行预测
* **译码** 根据`IR`中的4条指令进行译码并送到寄存器重命名模块
* **重命名** 将架构寄存器映射到物理寄存器上
* **分发** 寄存器重命名之后的指令被分发到定点或浮点保留站以便执行，同时送到重定序队列以便顺序完成；分支和存储加载指令被分发到对应的分支队列和存储加载队列。保留站和发射队列每项可保存分发4条指令
* **发射** 从保留站中选出操作数都准备好且最老的一个指令并发送到相应的执行单元，如果指令源操作数不可用，则侦听结果和前馈总线
* **执行** 执行单元从保留站中取出所有源操作数都准备好的指令进行运算，并将结果发送到结果和前馈总线
* **结束** 每周期可完成4条指令，完成的指令的结果被发送到寄存器映射模块以便更新架构寄存器同时释放资源

### 3.1.1 取指和分支预测
*GS464*包含 1 个4 路组相联 64 KB 的指令缓存, 其缓存行大小为 32 字节, 指令缓存的标签和数据部分同时访问并在下一时钟周期进行命中的判断与选择。其中数据部分划分为 8 个bank，每次取指令时只用读取所需要的bank, 降低了缓存访问时的动态功耗。指令缓存使用虚地址索引和实地址标识的索引方案。取指部件的虚实地址转换通过 16 项全相联结构的指令 TLB 完成, 指令 TLB 中的内容是页表的子集。其中, 每项存放 1 个页表项, 每个页表项均可支持 4 KB-1 GB 之间不同大小的页。当指令缓存命中时, 取指部件每个时钟周期最多可以从指令缓存中取出 4 条指令, 并送往下 一个流水级进行分支预测. 而当指令缓存未命中时, 取指部件将生成请求并访问缓存失效队列, 访存失效队列负责进行缓存缺失处理, 并将结果返回给指令缓存。从缓存失效队返回的结果将整体填回指令缓存， 指令缓存最多可容忍 3 个缓存行不命中, 即有 3 个未完成 (outstanding) 的缓存行不命中时, 依旧可以从正确的地址取指令。当取指请求恰好落在从缓存失效队列返回的缓存请求数据上时, 可以直接取出相应指令进入下一个流水级。此 外, 指令缓存的预取由缓存失效队列中的硬件预取引擎统一完成, 不在取指部件中单独进行。指令缓存的数据部分中还包含预译码信息, 每条指令的预译码信息为 8比特大小, 主要用于指令切分、分支类型判定和部分指令例外的判定。预译码信息通过在缓存失效队列重填指令缓存时计算得出, 并存储在指令缓存中。

在预译码阶段，会扫描`IR`里4条指令中的分支指令并预测分支方向和分支目标，`branch-like` 和 `jump` 指令总是预测执行，对于条件分支指令，则使用分支历史表(BHT)来预测分支方向，使用分支目标缓冲(BTB)和返回地址堆栈(RAS)预测分支目标地址。BHT由9比特全局历史寄存器(global history register) GHR 和4K模式历史表(pattern history table) PHT组成，PHT里每项有2比特的饱和计数器，高位用于分支方向预测。BTB有16项，每一项由指令地址和跳转指令目标地址以及2比特饱和计数器组成，计数器值为0或1的项首先被替换。RAS有4项，当遇到`branch and link` 指令时，将当前指令地址加8推进RAS，而遇到`jump register 31` 指令时从RAS中弹出指令地址。

在译码阶段，4条指令被译码并送到寄存器重命名模块。

### 3.1.2 寄存器重命名
*GS464*使用合并的架构和重命名寄存器堆，定点和浮点分别是64项，相应使用64项的PRMT(physical register mapping tables)来维护架构和物理寄存器之间映射关系。PRMT每项包含:
* 状态 每个物理寄存器处在下列状态之一：*MAP_EMPTY*，*MAP_MAPPED*, *MAP_WTBK*, *MAP_COMMIT*
* 名字 物理寄存器对应的架构寄存器标识
* 有效位 如果多个物理寄存器映射到一个架构寄存器，则标识最新的

寄存器重命名时，需要查找PRMT来找到两个源寄存器`src1`,`src2`，目标寄存器`dest` 对应的最新映射的物理寄存器`psrc1`, `psrc2`和`odest`。另外，一个处于*MAP_EMPTY*的物理寄存器`pdest`被映射到`dest`，且状态修改为*MAP_MAPPED*，有效位置1，`odest`有效位置0。之后映射的物理寄存器被送到保留站，`odest`保存在重定序队列以便指令结束时释放物理寄存器。当指令执行完成时，对应的PRMT项状态更新为*MAP_WTBK*, 指示后续依赖指令的操作数准备好了。当指令完成后，`pdest`的状态更新为*MAP_COMMIT*，`odest`更新为*MAP_EMPTY*。

### 3.1.2 指令发射
*GS464*有两个保留站，分别是定点和存储加载保留站和浮点保留站。每个保留站有16项，每周期可接收4条指令。每项包含一个年龄域，当指令进入保留站时设置成最小值，当同一个功能单元的新指令进入时，旧指令的值加一。从保留站中选出操作数都准备好且最老的一个指令并发送到相应的执行单元，如果指令源操作数不可用，则侦听结果和前馈总线

对于分支指令，除了发送到保留站和重定序队列之外，还会进入分支队列，每周期可接收一条分支指令，同时最多保存8条分支指令。当分支指令执行时，结果写回到分支队列，包括`JR`和`JALR`指令的地址，条件分支的分支方向，以及预测是否正确。每一个指令都会分配一个`brqid`，对于分支指令，指示在分支队列的位置，对于其他指令，标识了该指令前一个分支指令的位置。当分支预测错误时，该分支指令之后的指令都会被取消。

### 3.1.3 指令完成
寄存器重命名之后指令都被保存在重定序队列，直到指令完成。当指令执行结束且写回后，重定序队列按照程序顺序完成，重定序队列一共可以保存32条指令，每周期可接收4条指令。新进入的指令处于*ROQ_MAPPED*状态，当指令结果写回时后，对于分支指令，状态更新为*ROQ_BRWTBK*，其他指令则更新成*ROQ_WTBK*。对于分支指令，只有分支结果确定且对于预测错误的分支指令冲刷流水线之后才会更新成*ROQ_WTBK*。当指令到达重定序队列队头且处于*ROQ_WTBK*时才可以结束。每周期可完成4条指令。当指令完成时，`pdest`和`odest`发送到寄存器重命名模块以便更新处理器架构状态并释放`odest`项。对于产生异常的指令，也会在指令到达队头时处理。

### 3.1.4 访存队列
*GS464*有64K的指令缓存和数据缓存，都是4路组相联；64项的TLB，为全相联结构。访存队列一共有16项，最多可以跟踪16条存储加载指令。当加载指令进入队列时，会检查所有更老的存储指令；当存储指令进入队列时，会检查所有更年轻的加载指令。

# 4. Loongson 3B1000和3B1500
**龙芯3B1000**由核高基项目课题“高性能多核CPU研发与应用”支持，采用意法半导体65纳米工艺设计，主频1GHz，功耗25W，片内集成8个64位四发射乱序执行龙芯向量处理器核*GS464V*，4MB的二级缓存，每个核包含两个256位向量部件，峰值浮点性能达到128GFLOPS。**龙芯3B1000**的最大特色是龙芯向量处理器核的设计，该处理器核将*GS464*核的的浮点部件和浮点寄存器堆替换为2个256位的向量处理部件和1个128x256位的向量寄存器堆，使**龙芯3B**在1GHz下的峰值双精度浮点计算能力达到128GFlops。在**龙芯3B1000**处理器中，实现了300多条专用的向量处理指令。**龙芯3B1000**芯片面积 $300mm^2$ , 晶体管数目接近6亿。

**龙芯3B1500**集成了8个四发射乱序执行的64位*GS464V*处理器核，9级流水线，每个处理器核有64KB的私有一级指令缓存和64KB的私有一级数据缓存，128KB私有二级缓存，有8MB三级共享缓存，采用中芯国际32纳米工艺生产，芯片面积 $180mm^2$ , 晶体管数11亿，主频1.5GHz，单芯片双精度浮点计算能力达到192GFlops，功耗30w（典型）/60w（向量）。
有2个HT2.0，PCI、LPC、SPI、UART、GPIO，72位DDR2/3控制器。**龙芯3B1500**由2个处理器节点组成，每个处理器节点有4个*GS464V*处理器核，两个处理器节点之间通过交叉开关互联。下图展示了**龙芯3B1500** 整体架构图：
![Pasted image 20231019211906.png](/assets/images/godson/Pasted image 20231019211906.png)

下图展示了**龙芯3B1500**物理版图：
![3b1500.PNG](/assets/images/godson/3b1500.PNG)

## 4.1 GS464V微架构
*GS464V*在32nm工艺下面积为 $6.6mm^2$ ，有两个256比特的向量算术单元，每一个可以执行4个双精度的乘加运算；对外是一个128比特的AXI接口。下图展示了*GS464V*的物理规划图：
![Pasted image 20231019220550.png](/assets/images/godson/Pasted image 20231019220550.png)

下图展示了*GS464V*的微架构，和*GS464*的区别就是浮点单元换成了向量单元，其他流水线都是一样的。
![gs464v.PNG](/assets/images/godson/gs464v.PNG)

## 4.2 存储层次
**龙芯3B1500** 每个*GS464V*处理器核内有4路组相联64KB的指令缓存，4路组相联64KB的数据缓存，以及4路组相联作为victim缓存的128K的L2缓存；8个*GS464V*处理器核共享8MB的L3缓存。
![Pasted image 20231019221039.png](/assets/images/godson/Pasted image 20231019221039.png)
下图展示了各级存储测试的延迟：
![Pasted image 20231019221141.png](/assets/images/godson/Pasted image 20231019221141.png)

# 5. Loongson 3A2000
**龙芯3A2000**处理器集成了4个四发射乱序执行64位*GS464E*处理器核，也是首款采用*GS464E*微结构的处理器。 采用中芯国际40纳米CMOS工艺生产，主频800～1000MHz

*GS464E*处理器核是*GS464*的改进版，集成了64KB一级指令缓存，64KB一级数据缓存，256KB二级缓存和4MB三级缓存。流水线从GS464的9级提高到了12级。峰值浮点性能16GFlops。在接口上，**龙芯3A200**集成了两个HT3.0接口，PCI控制器、LPC、SPI、UART、GPIO，72位DDR2/3-1333×2控制器。

## 5.1 GS464E微架构
通过调研[IBM POWER7](https://zhifeiding.github.io/programming/history/2023/09/30/History-Of-POWER-What-Makes-POWER-so-Powerful/)等处理器，*GS464E*相比于之前的 *GS464* 架构, 重点强化了访存性能和分支预测准确率, 实现了 MIPS DSP 指 令集和虚拟机支持, 增大了处理器中各项队列的项数, 并增大了缓存容量和 TLB 容量。访存子系统拥有 3 级缓存结构, 每一级都采用 LRU 替换策略, 可以支持多核缓存一致性协议。下图展示了*GS464E*的物理规划图，主要由取指单元，寄存器重命名单元，定点单元，浮点单元，访存单元，L2缓存等组成。
![Pasted image 20231019103636.png](/assets/images/godson/Pasted image 20231019103636.png)
与*GS464*相比，*GS464E* 处理器核主要更新:
* **取指单元** 取指单元的功能是通过分支预测持续获得指令流, 并进行指令译码. 在 *GS464E* 处理器核中, 通过重新设计, 消除了分支指令预测跳转后的取指空泡; 通过加入循环缓冲器 (loop buffer), 使得最多 56 条指令组成的循环程序执行时不需访问指令缓存
* **寄存器重命名** 寄存器重命名部件的功能是进行各种寄存器的重命名, 用于动态流水线中的乱序发射。*GS464E* 处理器核中的寄存器重命名表扩展到 128 项定点物理寄存器和 128 项浮点物理寄存器, 此外, DSP 控制寄存器、HILO 寄存器以及浮点比较结果寄存器都单独进行重命名
* **指令重定序** 指令重定序单元的功能是将乱序发射的指令进行重定序, 并进行分支预测错与指令异常的处理. 指令重定序队列 (reorder queue, ROQ) 从 64 项增大到 128 项; 分支指令队列从 8 项 扩大到 24 项
* **定点单元** 定点单元用于进行定点计算. 在 *GS464E* 处理器核中, 通过激进的计算结果提前反馈 (forward) 逻辑设计, 存在寄存器数据相关的 2 条定点指令之间的延迟 (load-to-use) 从 2 个时钟周期减少到了 1 个; 此外还加入了数字信号处理 (digital signal processing, DSP) 功能单元
* **浮点单元** 浮点单元用于进行浮点计算. 浮点比较结果寄存器现在可以单独进行重命名, 因此浮点比较以及使用浮点比较结果的指令可以乱序发射和动态流水
* **访存单元** 访存部件用于处理访存指令. 访存指令专用发射队列大小为 32 项, 可以将访存指令乱序发射到 2 个访存功能部件, 每个功能部件均可执行读取 (load) 或存储 (store) 指令; 访存重定序队列的项数从 24 项提升至 64 项. 一级数据缓存采用了 LRU 替换策略, 并将 缓存行大小扩展为 64 字节长. 地址翻译快速查找表 (translation lookaside buffer, TLB) 的项数也有大幅扩充, 采用了 64 项可变大小页外加 1024 项固定大小页的双重 TLB 设计
* **缓存失效队列** 缓存失效队列由指令缓存失效请求与数据缓存失效请求所共用, 用于处理缓存失效并重填缓存行. 在 *GS464E* 处理器核中, 其项数从 8 项提升至 16 项, 并实现了激进的指令和数据预取引擎, 该预取引擎会根据缓存失效队列中的信息自动生成预取请求, 并通过缓存失效队列来处理这些预取请求. 该预取机制不会导致一级缓存污染
* **Victim Cache** Victim Cache 是片内的第二级缓存, 当一级缓存失效时被查询. 在 *GS464E* 处理器核中, 其总容量扩大为 256 KB, 相联结构从 8 路组相联改为 16 路组相联, 并采用了 LRU 替换策略, 提高了 Victim Cache 的命中率

下图展示了*GS464E*的微架构：
![Pasted image 20231019104824.png](/assets/images/godson/Pasted image 20231019104824.png)

### 5.1.1 取指单元
*GS464E*的取值单元主要包括L1指令缓存，指令TLB，分支预测器，指令队列和译码单元。下图展示了*GS464E*的取值单元的流水线：
![Pasted image 20231019105026.png](/assets/images/godson/Pasted image 20231019105026.png)
每个 *GS464E* 处理器核包含 1 个4 路组相联 64 KB 的指令缓存, 其缓存行大小为 64 字节, 指令缓存的标签和数据部分同时访问并在下一时钟周期进行命中的判断与选择。其中数据部分划分为 8 个bank，每次取指令时只用读取所需要的bank, 降低了缓存访问时的动态功耗。指令缓存使用虚地址索引和实地址标识的索引方案。取指部件的虚实地址转换通过 64 项全相联结构的指令 TLB 完成, 指令 TLB 中的内容是页表的子集。其中, 每项存放 1 个页表项, 每个页表项均可支持 4 KB-1 GB 之间不同大小的页。当指令缓存命中时, 取指部件每个时钟周期最多可以从指令缓存中取出 8 条指令, 并送往下 一个流水级进行分支预测. 而当指令缓存未命中时, 取指部件将生成请求并访问缓存失效队列, 访存失效队列负责进行缓存缺失处理, 并将结果返回给指令缓存。从缓存失效队返回的结果将整体填回指令缓存， 指令缓存最多可容忍 3 个缓存行不命中, 即有 3 个未完成 (outstanding) 的缓存行不命中时, 依旧可以从正确的地址取指令。当取指请求恰好落在从缓存失效队列返回的缓存请求数据上时, 可以直接取出相应指令进入下一个流水级。此 外, 指令缓存的预取由缓存失效队列中的硬件预取引擎统一完成, 不在取指部件中单独进行。指令缓存的数据部分中还包含预译码信息, 每条指令的预译码信息为 8比特大小, 主要用于指令切分、分支类型判定和部分指令例外的判定。预译码信息通过在缓存失效队列重填指令缓存时计算得出, 并存储在指令缓存中。

*GS464E* 处理器核采用了多种不同的机制来预测分支指令的跳转方向和跳转目标, 并通过分支目标缓冲器 (BrBTB) 来处理分支指令之后取指空泡的情况。分支预测机制在每个时钟周期最多可以处理 4 条分支指令, 但只有最后一条可以是预测为跳转的分支指令, 预测为跳转的分支指令的后续指令将在下一个时钟周期进行处理。*GS464E* 处理器核采用 3 个时钟周期延迟的 “取指 — 分支” 循环迭代设计,
* 第 1 个时钟周期 根据程序计数器 (program counter, PC) 的值访问指令缓存
* 第 2 个时钟周期 指令缓存查询完毕, 取出最多 8 条指令
* 第 3 个时钟周期 逐条解析指令, 预测分支指令的跳转方向和跳转目标, 如果取出的多条指令中存在预测为跳转的分支指令, 则需要根据此类指令中最早的那条来更新 PC 值

由于取出指令并预测出后续指令 PC 需要花费 3 个时钟周期, 其中有 2 个时钟周期无法确保能取出有意义的指令, 为避免性能损失, *GS464E* 处理器核实现了分支目标缓冲器 (BrBTB), 直接根据取指所使用的 PC 值预测后续指令的 PC 值。如果取出的指令中没有预测为跳转的分支指令, BrBTB 也没有预测出需要跳变的 PC 值, 则取指部件从当前 PC 向后顺序取指令。BrBTB 为 128 项全相联结 构, 使用当前时钟周期的 PC 值来索引下个时钟周期的预测 PC, 在其预测正确的情况下, 即使有需要跳转的分支指令, 取指流水线也不会断流。BrBTB 的功能是根据当前 PC 来预测下一个时钟周期的取指 PC, 用于消除分支指令之后的取指空泡, 但是分支预测工作还是需要解析不同的指令来进行不同处理的。

分支指令跳转方向的预测使用一套组合分支历史表 (BHTs), 包括 1 个 16384 项的全局分支历史表 (global branch history table, GBHT), 1 个 16384 项的局部分支历史表 (local branch history table, LBHT) 和 1 个 16384 项的全局选择历史表 (global branch select table, GSEL)。每个时钟周期取出的最多 8 条指令可以同时查找这套分支历史表，上述 3 个分支历史表中的每项都是 2 bit 饱和计数器, 其最高比特位在 GBHT 和 LBHT 中用于指明跳转方向, 而在 GSEL 中则用于决定选用 GBHT 还是 LBHT 的预测方向。

间接跳转指令的跳转目标预测分为两种情况:
* 函数返回跳转指令 (MIPS 指令集中的 JR r31 指令) 采用 16 项的返回地址栈 (return address stack, RAS) 进行预测。当分支预测阶段发现函数调用跳转指令时, 将该指令延迟槽之后指令的 PC 值压入 (push) 至 RAS 中。当分支预测阶段发现函数返回跳转指令时, 则弹出 (pop) RAS 栈顶所存放的 PC 值作为跳转目标的预测值。为了防止在错误推测路径上执行对 RAS 栈顶指令或栈顶内容的错误修改, RAS 的栈顶指针和当前栈顶的 PC 值都有其临 时备份, 用于自纠正
* 除上述函数返回跳转指令之外的的间接跳转指令使用项数为 1024 的跳转目标缓存器 (jump branch target address cache, JBTAC) 进行预测, 该缓存器使用取指 PC 及跳转历史信息进行索引。

当指令被取出后, 会根据预译码信息的指示, 按照不同的指令类型, 分别使用上述 3 种机制中的某 一种机制进行分支预测. 经过分支预测阶段后, 指令被存入大小为 64 项的指令队列中. 在 *GS464E* 处 理器核中, 基于该指令队列的资源还实现了循环缓冲器 (loop buffer). 循环缓冲器会监测进入指令队列的指令流 PC 特征, 当发现指令流中包含一个不大于 56 条指令的单层循环时, 将停止从指令缓存取指, 而是直接从指令队列中取出指令送到译码阶段. 当循环次数达到并退出循环时, 循环缓冲器会被清空.

译码功能部件在每个时钟周期会从指令队列头部取出 4 条指令进行译码。译码过程的行为较简单, 就是将指令码翻译为方便功能部件处理的内部码, 标识出指令类型、所需要操作的寄存器号以及指令码中可能包含的立即数, 用于接下来的寄存器重命名阶段。

### 5.1.2 指令分配与提交单元
指令分配与提交单元负责指令在处理器核中的分配与定序, 具体包括寄存器重命名，指令分配，指令发射，指令重定序，指令提交及分支与异常处理这几个功能。

译码后的指令首先进行寄存器重命名, 随后根据操作类型分配至不同的发射队列中。寄存器重命名是动态流水线中进行乱序发射的关键技术, 将为指令中指定的逻辑寄存器各自分配一个物理寄存器。在 *GS464E* 处理器核中, 需要进行重命名的寄存器有: 通用定点寄存器、通用浮点寄存器、HILO 寄存器、DSP 控制寄存器、浮点比较结果寄存器。这些需要重命名的寄存器各自进行映射, 通过物理寄存器映射表 (physical register map table, PRMT) 来保存物理寄存器和逻辑寄存器之间的关系. 用于通用定点寄存器重命名的为 128 项 64位宽的寄存器堆, 用于通用浮点寄存器重命名的为 128 项 64位宽的寄存器堆, 用于 HILO 寄存器重命名的为 16 项 128位宽的寄存器堆, 用于 DSP 控制寄存器 重命名的为 32 项 32位宽的寄存器堆, 用于浮点比较结果寄存器重命名的为 32 项 32位宽的寄存 器堆。

*GS464E* 处理器核中有 3 个独立的发射队列:
* 16 项的定点发射队列，定点发射队列负责源操作数和目标操作数均为通用定点寄存器、HILO 寄存器或 DSP 控制寄存器的运算指令和分支指令
* 24 项的浮点发射队列，浮点发射队列负责源操作数和目标操作数均为通用浮点寄存器或浮点比较结果寄存器的运算指令和分支指令
* 32 项的访存发射队列，访存发射队列除了负责所有定点，浮点的访存操作指令外, 还包括控制寄存器操作指令 (CP0 指令) 以及在定点与浮点寄存器间交互数据的指令
从控制功耗的角度出发, 3 个发射队列均采用移动指针而非移动队列中存储内容的管理策略, 每 个时钟周期需要计算当前应当发射指令的指针。只有源寄存器都已经就绪的指令才能被发射, 而指令在寄存器重命名阶段时就会先检查其源寄存器是否已经就绪。若其源操作数还没有准备好, 则该指令在进行指令分配以及在发射队列中的时候, 都要将自身的源寄存器号同结果总线或前馈总线的目标寄存器号相互比较, 以确定本条指令所需的源寄存器是否就绪。此时所使用的寄存器号都是经过寄存器重命名后的物理寄存器号。上述的 3 个发射队列都采用乱序发射机制, 指令的所有源操作数只要准备好就可以发射。当存在多个发射候选时, 最早进入的指令具有最高的优先级。

在 *GS464E* 处理器核中, 指令被顺序译码和重命名，乱序发射和执行, 但是要有序提交。重定序队列负责指令的有序结束, 它从寄存器重命名模块获取程序指令序信息, 并有序地保存流水线中所有已经完成寄存器重命名但未提交的指令。指令在功能单元执行完毕并写回 (writeback) 后, 重定序队列按照程序指令序顺序提交这些指令。重定序队列最多可同时容纳 128 条指令。重定序队列每个时钟周期最多可以提交队列顶端的 4 条已经处于写回状态的指令。指令的提交信息会送往寄存器重命名模块, 用于修改重命名的状态, 同时还需要通知访存重定序队列, 因为存储指令需要提交后才能修改存储器的内容。*GS464E* 处理器核实现了精确异常, 当取指令，译码或执行时发生异常时, 异常信息被送至重定序队列保存下来, 只有异常指令成为重定序队列头时, 才进行异常报告与处理。硬件进行的异常处理工作包括: 将异常原因、异常指令的 PC 值等信息记录到有关的 CP0 寄存器中, 并根据异常类型把异常处理程序的入口地址送到程序计数器中。

分支指令在寄存器重命名后进入重定序队列和发射队列的同时还会顺序地进入分支指令队列。*GS464E* 处理器核中的分支指令队列最多可以容纳 24 条分支指令, 该队列会记录分支指令进行分支预测时的预测结果。分支指令和其他指令一样都需要在功能部件执行, 但是其结果总线额外包含分支结果, 分支结果会写回到分支指令队列。这些结果包括 `JR` 和 `JALR` 指令的目标地址, 以及条件转移指令的转移方向, 利用这些结果可以判断这条指令的分支预测是否准确. 不论预测成功与否, 分支指令的执行结果都会反馈到取指部件, 用于修正相关的分支预测器, 以帮助后续分支指令的预测。预测错误的分支指令和在它之后取进来的指令都需要取消。分支指令队列负责发送分支错误取消总线, 根据队列中记录的程序指令序, 准确地进行分支取消操作, 同时将正确的 PC 值送到程序计数 器中。
### 5.1.3 定点单元和浮点单元
*GS464E* 处理器核中的定点单元包含 1 个多端口定点寄存器堆以及 2 个完全相同的定点运算单元。定点寄存器堆共 128 项, 一共有 8 个读端口和 4 个写端口。每条定点运算流水线中均包含: 用于 执行定点加、减、比较、陷阱指令的算术逻辑单元 (arithmetic logic unit, ALU), 用于执行移位、循环 移位和比特提取与截断指令的循环桶形移位器, 位操作单元, 前导零计数器, 分支处理单元, 除法部件和乘法器, 每种运算单元的数量均为 1 个。所有频繁执行的指令均在 1 个时钟周期内执行完毕, 且通过激进的前馈机制设计, 使得存在寄存器相关的多条指令可以背靠背连续发射。乘法器采用全流水设计, 可进行 64x64有符号或无符号乘法运算, 运算延迟为 3 个时钟周期, 全流水设计使得每个乘法器在每个时钟周期都可接受 1 条新的指令, 并产生 128比特的乘积结果。

*GS464E* 处理器核中的浮点部件包含 1 个多端口浮点寄存器堆以及 2 个完全相同的浮点运算单元。浮点多端口寄存器堆共 128 项, 一共有 8 个读端口和 4 个写端口。每条浮点运算流水线中均包含: 格式转换单元 (用于执行 “定点转为浮点”，“单精度浮点转为双精度浮点” 这类格式转换指令), 浮点比较单元, 浮点除法单元, 浮点开方与求倒数单元, 以及浮点乘加 (fused multiply–add) 单元 (用于执行浮点加、减、乘、乘加、乘减指令), 每种运算单元的数量均为 1 个。其中格式转换单元采用 3 级全流水设计, 浮点乘加单元采用 4 级全流水设计。

### 5.1.4 访存单元
访存部件包含以下的子部件: 访存指令发射队列 mmqueue，访存专用定点寄存器堆 mr，两个访存地址生成部件 memaddr, 一级数据缓存，一级数据 TLB ，两 个访存标签比较部件 dtagcmp、访存重定序队列 cp0queue, 以及二级 TLB 部件 sec tlb。只有一份的子部件由两条访存流水线共享使用。下图展示了访存单元流水线：
![Pasted image 20231019105057.png](/assets/images/godson/Pasted image 20231019105057.png)
访存指令发射队列 mmqueue 接收寄存器重命名部件送来的指令信息, 并将当前已经就绪且 程序指令序上最老的访存指令发射到访存流水线上。大部分访存指令都可以在两个访存部件中的任意一个执行, 存储操作和加载操作一样, 会等待地址和数据同时就绪后, 才发射到流水线中。两条访存流水线在拥有 4 个读端口的寄存器堆 mr 中读取所需的操作数; 一些特殊指令需要发送额外请求去定点部件或浮点部件, 以获取所需的源数据, 例如, 浮点存储指令 `SDC1` 所需要存储的数据只存放在浮点寄存器堆中。所有类型的访存指令的地址肯定会存放在 mr 中, 不需要从定点部件或浮点部件取。两条访存流水线分别拥有一个地址计算模块 memaddr，地址计算模块根据访存指令的类型, 利用 mr 读出的寄存器内容计算访存指令的虚拟地址 (effective address, EA 或虚地址)。虚地址低位送到数据缓存模块进行索引查找, 整个虚地址送到 DTLB 模块进行虚实地址翻译。
一级数据缓存是由 4 路组相联、每一路 16 KB 大小的双端口随机存储器 (random access memory, RAM) 构成的, 两个端口分别对应一条访存流水线。每个端口根据地址的低位读取 RAM 中存放的标签和数据, 并将读出的结果送至 dtagcmp 部件准备进行标签比较。同时, 存储指令需要存储的数据在此单元计算, 同样也送到 dtagcmp 部件。一级数据 TLB 与一级数据缓存同时被查询。一级数据 TLB 部件使用 2 个 64比特虚地址作为输入, 查询双端口的全相联组织的 DTLB, 得到 2 条访存指令的虚地址所对应的 48比特物理地址 (physical address, PA 或实地址), 并送至 dtagcmp 模块准备进行标签比较。此外, 大部分 CP0 相关的特权指令, 如 MTC0 及 MFC0 都是在 DTLB 模块执行的。两个实地址比较模块 dtagcmp 模块分别对应一条访存流水线。这个模块将数据缓存模块读出的 4 路标签与 DTLB 模块得到的实地址进行比较, 确定一级数据缓存是否命中, 以及命中在哪一路。命中路的数据会被取出, 和数据送来的 存储指令所要存储的数据一起计算, 得到访存指令的执行结果, 并送到访存重定序队列 cp0queue。访存重定序队列 cp0queue 接收程序指令序信息, 接收 dtagcmp 模块送来的指令地址与数据信 息, 并通过回滚机制来维护乱序发射的访存指令之间的正确执行序。Cp0queue 除了访存指令重定序工作之外, 在每个时钟周期还需要写回最多 2 条可写回的 加载指令和 最多 2 条可写回的存储指令，将最多 1 条访存失效的指令送往缓存失效队列，将最多 2 条已经提交 且被允许写一级数据缓存的存储指令发送到一级数据缓存的写端口。Cp0queue 可以被视作访存指令的归宿, 所有访存指令都在这里进行缓存失效处理和写回。目标寄存器为定点寄存器的加载类型访存指令在从数据缓存流水级到 dtagcmp 流水级传递时, 会进行猜测提前反馈操作, 称为 specfwd。在从 dtagcmp 流水级到 cp0queue 传递时, 会重新发送上一 个时钟周期的 specfwd 信息, 形成 fwdbus 总线。两条访存总线的最多 4 条用于提前反馈的信息会被 送至定点发射队列和访存发射队列, 并置猜测就绪标记, 使得指令可以猜测地发射。如果猜测前馈猜测错误, 则会发送对应该访存流水线的猜测取消信号 spec cancel, 猜测错误的条件包括: 一级数据缓存未命中，或者一级 DTLB 未命中，或者该指令在 cp0queue 被回滚。猜测取消信号将会取消对应的 specfwd 以及 fwdbus 总线带来的所有后果, 已经猜测发射的相应指令也会被取消, 并回到发射队列重新等待发射机会。在上述 前馈机制的作用下, 可以得知访存指令在理想情况下的延迟: 访存指令到定点指令以及访存指令到访存指令的 load-to-use 延迟为 4 个时钟周期, 访存指令到浮点指令的 load-to-use 延迟 为 6 个时钟周期。

访存重定序机制是用于维护乱序发射的访存指令之间执行顺序的机制。在之前的 *GS464* 处理器核设计中, 访存重定序采取的是数据传递机制, 使用数据传递机制进行访存指令重定序的方法为: 当一条指令经过发射路径到达重定序队列时, 这条指令需要从所有执行序在它之前的，与其相关的存储指令处获取对应数据; 同时, 如果这条指令是存储指令, 那么这条指令还要将它自己的数据传递给所有的已经在重定序队列中与其相关的且执行序在它后面的指令。简单说来, 该机制可以描述成 “取前给后”。在物理设计上, 实现这样的数据传递机制代价很大: 该指令可能从多条指令处取得数据, 可能从任意指令处拿取任意字节的数据; 存储指令可能把自己的数据传递给多条指令, 可能将数据传递给任意指令的任意字节位置。这个机制的物理设计过于复杂, 严重限制了队列的规模, 致使 *GS464* 处理器核中的访存重定序队列只有 24 项大小。 在 *GS464E* 处理器核中实现了 2 个访存功能单元, 同一时刻可能有 2 条指令进入访存重定序队列, 数据传递机制的实现代价更是难以接受。为了提高指令并行度，将访存重定序队列项数增大, 在 *GS464E* 处理器核中, 只保留了指令是否相关的判断, 取消了数据传递的功能, 通过指令回滚到发射队列重新发射的机制来保证执行的正确性。其具体操作方式如下所述: 当一条指令经过发射路径到达重定序队列时, 发现队列中有执行序在它之前的与其相关的存储指令, 那么该指令回滚到访存发射队列 mmqueue, 并等待该存储指令写入一级数据 缓存后再次发射; 如果一条存储指令经过发射路径到达重定序队列时, 发现队列中已有执行序在它之后的与其相关的指令, 那么将这些指令回滚到 mmqueue, 让这些指令重新发射。其中, 指令相关的判断会根据指令的操作类型，访存地址等信息进行精确的判断, 例如, 对 A 地址的半字存储 SH 操作并不会使得对 A+2 地址的半字取 LH 操作回滚。简单说来, 该机制可以描述为 “等前打后”。通过采取 “等前打后” 的访存重定序策略来代替 “取前给后” 的策略, 略增加了发射队列和访存重定序队列的设计复杂度, 在一些情况下会带来少许性能降低, 但是却大大降低了物理设计的难度, 可以在同样的设计主频下使用更大的访存重定序队列, 增加访存指令并行度, 可以更好的容忍访存延迟。同时, 也为支持更大的访存宽度, 如 256比特向量访存指令, 提供了可能性。

*GS464E* 处理器核中的一级数据缓存采取 4 路组相联结构, 总大小为 64 KB。其中, 每一路大小为 16 KB, 分为 256 个缓存行, 每一行为 64 字节。一级数据缓存使用虚地址索引, 实地址标识, 每一个缓存行需要 48比特的标签来存储实地址信息, 以及 512比特的数据来存储数据, 标签和数据部分都使用 ECC 校验码来进行冗余保护。一级数据缓存采用 LRU 替换策略, 当一个缓存行被查询命中时, 或因缓存失效而被新填入时, 会被调整到最难被替换的优先级; 如果一个缓存行因多核一致性导致的外部请求被无效, 该缓存行会被调整至最容易被替换的优先级。一级数据缓存是一个双端口的缓存结构, 每一个时刻最多可以实现 2 条访存指令的查询操作；同时, 存储指令从访存重定序队列发出写缓存操作时, 也通过这 2 个端口进行写操作, 其优先级低于访存指令的查询操作。除此之外, ECC 校验出错时的自纠正操作和缓存失效重填请求都需要从第一个写端口进行写入, 写入操作将按照特定优先级进行, 并对低优先级的操作产生阻塞。

虚实地址翻译工作在硬件实现上是由两级 TLB 来完成的。一级数据 TLB 对软件透明, 每次访存操作执行时被查询; 软件可见的是二级 TLB, 软件修改 TLB 的指令 (如 TLBWR) 会直接修改二级 TLB。 二级 TLB 对一级数据 TLB 是包含关系, 一级数据 TLB 的缺失会自动从二级 TLB 中查找并取 回, 硬件会自动维护包含关系。 此外, 指令 TLB 也是根据二级 TLB 中的内容填入的。 一级数据 TLB 的规模为 32 项, 二级 TLB 则是由 2 个部分组成, 包括 64 项全相联的可变页大小的地址可寻址存储器 (content addressable memory, CAM) 部分, 以及 8 路组相联，每一路 128 项, 共计 1024 项的固定页大小的 RAM 部分, 这两级 TLB 中的每一项都可以装载 1 个标准 MIPS 双页。一 级数据 TLB 是双端口的, 分别对应于 2 个访存功能部件, 一级 TLB 查询发生不命中时, 会选择在程序指令序上较老的那条指令来查询只有 1 个端口的二级 TLB。二级 TLB 查询需要花费 2 个时钟周期, 如果命中, 那么命中的结果会写入一级数据 TLB, 其替换策略为随机替换; 如果未命中, 其结果也会通知访存重定序队列。需要查询二级 TLB 的指令经过访存重定序队列中的回滚机制, 重新回到发射队列, 再次发射时, 二级 TLB 的查询结果已经返回, 因此可以判断是否真正的发生了 TLB 失效异常。 二级 TLB 中可变页部分 (CAM 部分) 和固定页部分 (RAM 部分) 会被同时查询, 但是软件进行 TLB 写入时, 只有其中一个会被修改: 如果写入项的页大小与提前配置好的固定页相同, 则 TLB 指令 会将 TLB 表项写入固定页部分, 否则, 将写入可变页部分。 64 项的 CAM 部分和 8 路组相联的 RAM 部分都采用随机替换策略。

*GS464E* 处理器核的一级数据缓存是一个写回 (writeback) 式的缓存, 所有的存储操作都需要对一级数据缓存进行写入。 当存储指令发生缓存失效时, 需要将存储指令所需的缓存行从内存搬运至一级数据缓存, 再进行写入。然而在很多情况下, 存储指令都倾向于填满整个缓存行, 因此这个搬运过程就显得多余, 还带来了不少的时间与功耗开销。 为了降低这个开销, *GS464E* 处理器核中引入了存储填充 (store fill) 机制。该机制的工作原理为: 当存储指令在一级数据缓存中发生缓存失效时, 其访存失效请求会将待存储的数据一并送至位于缓存失效队列中的存储填充缓冲区, 同时, 该访存失效请求暂缓访问 SCache。如果接下来的多条存储请求在该缓冲区中成功地拼满了缓存行, 那么只需向 SCache 请求空白的缓存行即可。收到空白行请求的 SCache 不会访问内存, 在进行多核一致性处理后直接返回, 缓存失效队列负责将缓冲区中拼满的数据重填回一级数据缓存。在存储填充进行期间, 相应的存储指令可以退出流水线, 释放队列空间。如果较长时间没有拼满一个缓存行, 或遇到了属于同一个缓存行的加载操作, 或遇到内存屏障类操作 (如 SYNC 或 CACHE 指令), 存储填充机制就会进行退出处理, 向 SCache 请求一个正常的缓存行, 待结果返回后, 在缓冲区进行数据拼凑操作, 将拼凑后的结果填回一级数据缓存。 硬件会记录存储填充成功与否的近期历史, 并对存储填充机制进行自动调整。 *GS464E* 处理器核中实现的存储填充机制可以适用于多核处理器的情况, 减少了存储指令导致的内存读取, 并允许存储指令提前退出流水线, 提升了处理器的整体执行性能。

### 5.1.5 缓存失效队列
缓存失效队列位于一级缓存与 SCache 之间, 负责对 Victim Cache 进行访问和管理, 实现缓存失效请求的处理和重填工作, 并负责硬件预取请求的生成和处理。 在 *GS464E* 处理器设计中, 对缓存失效的处理过程进行了多项创新性的改动, 包括基于缓存失效队列的无污染硬件预取引擎设计以及可以支持多核情况的存储填充机制。

缓存失效队列共有 16 项, 进入该队列的请求包括访存重定序队列发来的访存失效请求、取指部件发来的指令失效请求以及 SCache 发来的多核一致性请求, 此外, 硬件预取引擎会将生成的数据和指令预取请求也送给缓存失效队列, 由该队列进行处理。所有进队请求的地址均为实地址。缓存失效队列中的缓存失效请求会先查询 Victim Cache, 如果命中, 则会将结果重填回一级缓存, 并将一级缓存替换出的缓存行填入 Victim Cache 中之前被取出的位置; 如果 Victim Cache 查询未命中, 则会访问 SCache, 待 SCache 的结果返回后, 填入一级缓存, 将一级缓存替换出的有效数据根据 LRU 算法写入 Victim Cache, 并将 Victim Cache 替换出的有效脏数据写回到 SCache。 缓存失效请求总是会先查询 Victim Cache, 查询未命中时再查询 SCache, 这种串行访问的设计降低了缓存一致性维护的复杂度。缓存失效队列中由 SCache 发来的多核一致性请求会对一级缓存和 Victim Cache 进行查询, 根据查询结果和一致性请求的类型, 对缓存行进行无效、写回等操作, 并将结果返回 SCache。缓存失效队列中的硬件预取请求会对 SCache 进行查询, 根据查询结果, 将预取来的数据暂存在队列中。如果有缓存失效请求和硬件预取请求操作同一个缓存行, 那么预取到的数据会发送给这个缓存失效请求。缓存失效队列会定期清除掉那些一直没有被使用到的预取数据。这样的预取处理方式不会带来任何一级缓存污染。请求同一个缓存行的缓存失效操作会在缓存失效队列中进行合并, 但只限于同属于数据缓存失效或指令缓存失效。缓存失效队列还有专门的缓冲区用于存储访存失效存储指令的数据, 以支持存储填充机制。

*GS464E* 处理器核中使用了最多同时支持 4 个数据访问流和 1 个指令访问流的流式硬件预取引擎, 数据和指令的预取相对独立。 其中, 数据流式预取引擎可以支持升序和降序模式, 使用访存失效请求来建立和维护访问流信息; 而指令预取只能支持升序的预取, 使用指令失效请求来建立和维护流信 息。 当失效请求为连续的 2 个缓存行时, 将会建立访问流, 每个访问流都配有 3比特的倒数计数器, 用于计算这个访问流是否已过期。缓存失效请求如果在某个访问流上延续, 那么配属于这个访问流的计数器会刷新到最大值。访问流建立后, 就可以触发预取, 预取请求的触发包括下列两种情况. 如果缓存失效请求在缓存失效队列中和预取请求合并, 证明预取是有益的, 将会根据此次失效的地址查询预取引擎中已经建立的访问流信息。指令失效请求会查询指令预取引擎, 而访存失效请求会查询数据预取引擎。如果访问流查询命中, 则根据访问流的升序或降序信息, 产生 1 个预取请求, 预取请求的地址是失效地址加上特定增量; 如果访问流查询不命中, 则寻找计数器为零或计数器最小的访问流, 将其顶替。如果未能和预取请求合并的缓存失效请求在 Victim Cache 中查询未命中, 则证明需要进行预取, 此时会根据此次失效的地址查询预取引擎中的访问流信息, 如果访问流信息查询命中, 则根据访问流的升序或降序信息, 产生预取请求, 预取请求地址是失效地址加上特定增量; 访问流查询未命中则不进行操作。每次触发预取时, 预取地址相对于失效地址的增量会随着这个访问流的历史触发次数而变化, 被触发过的次数越多, 其预取增量越大。这个增量值的上限则由已建立的访问流的个数决定: 当只有 1 个访问流存在时, 增量上限被设定为 4 个缓存行大小; 当超过 1 个访问流时, 该增量被设定为 2 个缓存行大小，指令预取的增量上限一直设定为 4 个缓存行。*GS464E* 处理器核使用增量预取策略, 相对于每次触发就预取多条的策略, 在访问流预测正确的情况下效果是相同的, 但是访问流预测错误时, 增量预取策略会少一些无效的预取请求。

## 缓存
*GS464E* 处理器核使用了三级片上缓存结构, 其中位于每个处理器核内部的私有缓存包括一级数据缓存和一级指令缓存, 以及数据和指令共用的 Victim Cache, 第三级缓存为 SCache, 由所有处理器核共享。一级指令缓存为 4 路组相联设计, 64 KB 容量, 缓存行大小64 字节, 随机替换。一级数据缓存采用 LRU 替换策略，4 路组相联设计, 64 KB 容量, 缓存行大小64 字节。 Victim Cache 与两个一级缓存是exclusive关系, 处于一级缓存中的缓存行必定不存在于 Victim Cache 中; Victim Cache 与 SCache 维护包含 (inclusive) 关系, 也即处于 Victim Cache 中的缓存行必定在 SCache 中有其对应的备份。一级缓存和 SCache 是Inclusive关系。

Victim Cache 为 16 路组相联, 每一路 16 KB, 共计 256 KB, 缓存行大小为 64 字节, 使用 LRU 替换策略。Victim Cache 位于一级缓存之下, 由缓存失效队列进行管理, 当一级缓存发生缓存失效时被查询。 查询 Victim Cache 时, 先读取标签再读取命中路的数据的方式, 使用少量延迟来换取功耗的降低。 在缓存失效请求查询 Victim Cache 未命中情况下, 由缓存失效队列负责向 SCache 发出失效请求. 当一个缓存行从一级缓存中替换出来时, 会被填入 Victim Cache, 而 Victim Cache 替换出的数据将会写回到 SCache。 指令缓存行与数据缓存行都可以存放在 Victim Cache 中, 以缓存行标签域中的一个额外比特来做区分。

SCache 为片上末级缓存, 由所有处理器核共享, 一个四核处理器就会拥有 4 个 SCache 以 供 4 个处理器核使用。每个 SCache 为 16 路组相联, 容量为 1 MB, 缓存行大小为 64 字节, 使用 LRU 替换算法。 每个 SCache 使用大小为 16 项的管理队列来查询和维护. 相比于一级缓存和 Victim Cache, 每个 SCache 的缓存行还额外包含 64比特的目录域, 用于记录该 缓存行被哪个处理器核持有, 以及被处理器核持有的是指令行还是数据行。在这个目录的设计规模下, 最多支持一个芯片集成 32 个处理器核. 在区分数据行和指令行之外, SCache 并不区分一级缓存和 Victim Cache, 因此一级数据缓存持有的缓存行或 Victim Cache 持有的数据缓存行都会被视作该处理器核持有数据缓存行。在 *GS464E* 处理器核配属的 SCache 中, 加入了基于缓存一致性的硬件抗别名设计。当程序使用的页的大小比一级缓存中每个缓存路的容量更小的情况下, 就会出现别名的情况, 同一个物理地址会被放置在一级缓存中的多个索引上。为了保证映射到同一个物理地址的多个虚地址之间的数据是一致的, SCache 在标签域中加入了额外的 2比特的页染色域, 利用 SCache 对片内两级缓存的包含关系, 保证这个缓存行只能存在于满足当前页染色域的特定索引位置上。当一个访存请求要求页染色域的另一个值时, 会发生缓存失效, SCache 发现该请求页染色不命中之后, 会通过一致性请求, 写回并无效处于一级缓存或 Victim Cache 之中的缓存行备份, 修改页染色域的值为新值后, 再行返回, 以此保证每个物理地址只对应一个实例。基于缓存一致性的硬件抗别名设计是 *GS464E* 处理器核的创新性功能, 在保持一级缓存大容量的前提下, 实现了对较小页的高效硬件支持。SCache 中还为使用原子操作指令 (例如, LL/SC 指令) 进行多核的同步加入了特殊设计: 当一个 处理器核使用原子操作指令获得一个缓存行时, SCache 在短时间内将禁止把这个缓存行转让给其他处理器核。该时间间隔为随机数, 随机的范围可以通过软件进行配置。通过上述设计, 多个处理器核同时争抢同一个内存地址时, 可以在时间上串行开来, 减少了竞争。这个特殊设计可以提高多核同步的性能, 并可以防止因每个处理器核都占有时间过短，无法修改共享数据而导致的活锁现象。在 SCache 中查询失效的请求会向下一级存储设备发出访存请求。下一级存储设备包括内存, PCI, SPI 或其他外部设备。

在一级数据缓存命中的加载指令延迟为 4 个时钟周期；在 Victim Cache 命中, 则会给这条访存指令带来额外 18 个时钟周期的延迟；如果是 Victim Cache 也失效但是在 SCache 中命中的访存指令, 相比一级缓存命中的情况要多 50 个时钟周期的延迟, 其中访问 SCache 需要的时间为 11 个时钟周期, 其他延迟包括请求在片内传递的延迟, 以及为支持处理器核降频设计所需要的异步队列所带来的延迟。

# 6 Loongson 3A3000
**龙芯 3A3000/3B3000**主频 1.2Hz–1.5GHz，为4核处理器，采用4个四发射乱序执行的64 位超标量处理器核*GS464E*，支持 MIPS64 指令集，支持龙芯扩展指令集，采用12 级超标量流水线; 每核有2 个定点单元、2 个浮点单元和 2 个访存单元。每个处理器核包含 64KB 私有一级指令缓存和 64KB 私有一级数据缓存;每个处理器包含 256KB 私有二级缓存;所有处理器核共享 8MB 三级缓存。

和**龙芯3A2000**相比，除了流片工艺从中芯国际的40纳米提升到意法半导体的28纳米CMOS 工艺，处理器的三级缓存也从4MB提高到8MB。峰值浮点性能24GFlops，典型功耗 <40W@1.5GHz。集成的接口有两个HT3.0接口，PCI控制器、LPC、SPI、UART、GPIO，两个72位DDR2/3-1600，支持ECC。

# 7 Loongson 3A4000
**龙芯3A4000**采用**龙芯**最新研发的*GS464V*，尽管**龙芯3A4000**仍然采用28nm工艺, 但主频提高到2.0GHz, 综合性能是上一代**龙芯3A3000**的两倍。用于片间互连及连接桥片的HT控制器带宽提高一倍以上，内存控制器从DDR3升级到DDR4，对虚拟机支持更加完善，效率达到95%以上。**龙芯3A4000/3B4000**也是首次在片内集成漏洞防范设计、硬件国密算法、安全可信模块与安全访问控制机制的处理器。**龙芯3B4000**在**龙芯3A4000**的基础上支持多路互连。
![Pasted image 20231019101252.png](/assets/images/godson/Pasted image 20231019101252.png)
# 8 Loongson 3A5000
**龙芯3A5000**采用和**龙芯3A4000**的处理器同样的*GS464EV*, 采用12nm工艺流片, 主频提升到2.5GHz。**龙芯3A5000**依然是4核处理器，而**龙芯3C5000**将是一款16核处理器。**龙芯3A5000/3B5000**是面向个人计算机、服务器等信息化领域的通用处理器，基于龙芯自主指令系统*LoongArch*的*LA464*微结构的四核处理器，在与**龙芯3A4000**处理器保持引脚兼容的基础上，频率提升至2.5GHz，功耗降低30%以上，性能提升50%以上。**龙芯3B5000**在**龙芯3A5000**的基础上在HT0接口上支持一致性互联以便支持多路互连。下图展示了其芯片架构：
![Pasted image 20231018222854.png](/assets/images/godson/Pasted image 20231018222854.png)
第一级互联采用5x5的交叉开关，用于4个处理器核，4个共享缓存模块和一个IO端口的连接。第二级互联采用5x3的交叉开关，连接4个共享的缓存模块，两个内存控制器和一个IO端口。IO环总线一共8个端口，分别连接4个HT控制器，慢速输入输出模块，安全模块以及两级交叉开关。两个HT控制器共用16条HT总线，可以作为两个8位HT或一个16位HT使用。

上述互联结构都采用读写分离的数据通道，位宽128比特，与处理器同频；处理器核和第一级交叉开关读通道是256比特。

下图展示了**龙芯3A5000**的物理规划版图：
![Pasted image 20231019182021.png](/assets/images/godson/Pasted image 20231019182021.png)

## 8.1 LA464处理器核
*LA464*是一个4发射的超标量处理器，有4个定点单元，2个256位的向量单元和2个访存单元。每个向量单元支持8个单精度或4个双精度乘加运算；访存单元支持256位存储访问.下图展示了*LA464*处理器核的微架构：
![Pasted image 20231018231056.png](/assets/images/godson/Pasted image 20231018231056.png)

### 8.1.1 共享缓存

Scache模块是**龙芯3A5000**内部所有处理器核共享的L3缓存，采用16路组相联，由缓存管理模块和缓存访问模块组成：
* **缓存管理模块** 负责处理来自处理器和DMA的访问请求
* **缓存访问模块** 负责存放缓存标签，目录和数据

### 8.1.2 SMP互联
通过HT进行互联可以组成2路，4路，8路或16路SMP系统，整个系统物理地址宽度为48位，地址高4位用来识别单个节点，每个节点实际可用地址空间是44位。当系统节点数目不足16时，需要配置路由设置寄存器，保证没有对应节点的地址能够返回响应。

# 9 Loongson 3A6000
**龙芯3A6000**处理器是**龙芯**第四代微架构的首款产品，集成4个最新研发的高性能6发射64位*LA664*处理器核。主频达到2.5GHz，支持128位向量处理扩展指令（LSX）和256位高级向量处理扩展指令（LASX），支持同时多线程技术（SMT2），全芯片共8个逻辑核。**龙芯3A6000**片内集成双通道DDR4-3200控制器，集成安全可信模块，可提供安全启动方案和国密（SM2、SM3、SM4等）应用支持。较上一代**龙芯3A5000**桌面CPU，**龙芯3A6000**在相同工艺下单线程性能提升60%以上，全芯片多线程性能成倍提升。

# 参考文献
1. LoongArch-Vol1-v1.02
2. Loongson 3A5000/3B5000 Processor Reference Manual - Multicore Processor Architecture, Register Descriptions and System Software Programming Guide, n.d.
3. Wang H., Wang W., Wu R., Hu W., 2015. 龙芯GS464E处理器核架构设计. Sci. Sin.-Inf. 45, 480–500. [https://doi.org/10.1360/N112014-00292](https://doi.org/10.1360/N112014-00292)
4. Hu, W., Wang, J., Gao, X., Chen, Y., Liu, Q., Li, G., 2009. Godson-3: A Scalable Multicore RISC Processor with x86 Emulation. IEEE Micro 29, 17–29. [https://doi.org/10.1109/MM.2009.30](https://doi.org/10.1109/MM.2009.30)
5. W. Hu et al., "Godson-3B1500: A 32nm 1.35GHz 40W 172.8GFLOPS 8-core processor," 2013 IEEE International Solid-State Circuits Conference Digest of Technical Papers, San Francisco, CA, USA, 2013, pp. 54-55, doi: 10.1109/ISSCC.2013.6487634.
6. W. Hu et al., "Godson-3B: A 1GHz 40W 8-core 128GFLOPS processor in 65nm CMOS," 2011 IEEE International Solid-State Circuits Conference, San Francisco, CA, USA, 2011, pp. 76-78, doi: 10.1109/ISSCC.2011.5746226.
7. Gao, X., Chen, Y.-J., Wang, H.-D., Tang, D., Hu, W.-W., 2010. System Architecture of Godson-3 Multi-Core Processors. J. Comput. Sci. Technol. 25, 181–191. [https://doi.org/10.1007/s11390-010-9315-3](https://doi.org/10.1007/s11390-010-9315-3)
8. Hu W W, Tang Z M. Microarchitecture design of the Godson1 Processor. Chinese Journal of Computers, April 2003, 26(4): 385-396.
9. Hu W W, Zhang F X, Li Z S. Microarchitecture of the Godson-2 processor. Journal of Computer Science and Technology, March 2005, 20(2): 243-249.