---
title : Heap
category : Programming
tags : [C++,Data Structure]
---

# 什么是Heap ?

数据结构中的Heap是一种满足heap property的树:

* 父节点和子节点按照给定顺序， 并应用在整棵树上

根据父节点和子节点不同顺序又可以分为：

* min-heap(最小堆)：

  1. 父节点比子节点小
  2. 最小值在根节点

* max-heap(最大堆)：

  1. 父节点比子节点大
  2. 最大值在根节点

比较常用的堆是二叉堆，在结构上是一个complete binary tree。 因此，对于N个节点的二叉堆，高度是 logN 。
二叉堆不同于二叉查找树， 即按照in-order遍历不会使数据有序，二叉堆每个节点和它的silblings并没有什么关系。

数据结构中的Heap不要和memory中的heap混淆。

[wikipedia](1)

# 为什么要用到Heap[^1]?

通过上面对Heap的了解，我们可以知道下面几种情况可能比较适合使用Heap:

* 需要sort或partially sort的应用
* 需要取极值的情况
* 需要优先级的场景

常用的priority queue其实就是用Heap来实现的。

# 怎么实现?

## Heap上常用的操作

* find-min/find-max : 取得极值
* extract-min/extract-max : 删除极值
* insert ：插入一个值， 可能violate heap property， 需要rebalance 二叉堆
* empty/size : 需要得到heap大小或判断是否为空
* replace : 替换一个值， 需要重新rebalance

## 代码

```c++
#ifndef _HEAP_HPP_
#define _HEAP_HPP_

#include <vector>
#include <functional>
#include <exception>

template<typename T, typename comparator = std::less<T> >
class heap {
public:

    // empty arguments constructor
    heap(comparator cmp = comparator());
    // one argument constructor ( default comparator )
    heap(const std::vector<T> &nums, comparator cmp = comparator());
    // iterator constructor

    // copy constructor
    heap(const heap *other);

    // assign constructor
    const heap &operator=(const heap *other);

    // find min/max
    const T top() const;

    // extract top
    void pop();

    // insert value
    void push(T val);

    // size -- returns the number of elements
    const size_t size() const;

    // empty -- checks whether the heap is empty
    const bool empty() const;

    // destructor
    ~heap();

private:
    std::vector<T> data;
    comparator comp;
    void percolateDown(int idx);
    void percolateUp(int idx);
};

// one default argument constrctor
template<typename T, typename comparator>
heap<T,comparator>::heap(comparator cmp) : comp(cmp) {
    // just initialize the data to size 1
    data.resize(1);
    //this->comp = cmp;
}

// two argument constructor
template<typename T, typename comparator>
heap<T, comparator>::heap(const std::vector<T> &nums, comparator cmp) {
    this->data.resize(nums.size()+1);
    this->comp = cmp;

    // copy nums to data
    copy(nums.begin(), nums.end(), data.begin()+1);
    // balance the heap
    for(int idx = this->size()/2;idx > 0;--idx)
        percolateDown(idx);
}

// copy constructor
template<typename T, typename comparator>
heap<T,comparator>::heap(const heap *other) {
    copy(other->data.begin(), other->data.end(), this->data.begin());
    this->comp = other->comp;
}

// assign constructor
template<typename T, typename comparator>
const heap<T,comparator>& heap<T,comparator>::operator =(const heap *other) {
    copy(other->data.begin(), other->data.end(), this->data.begin());
    this->comp = other->comp;
    return this;
}

// destructor
template<typename T, typename comparator>
heap<T,comparator>::~heap() {
}

// find-min/max
template<typename T, typename comparator>
const T heap<T,comparator>::top() const {
    if( !empty() )
        return data[1];
}

// remove the top element
template<typename T, typename comparator>
void heap<T,comparator>::pop() {
    if( !empty() ) {
        data[1] = data[size()];
        data.resize(size());
        percolateDown(1);
    }
}

// insert an element
template<typename T, typename comparator>
void heap<T,comparator>::push(T val) {
    this->data.push_back(val);
    percolateUp(size());
}

// check whether the heap is empty
template<typename T, typename comparator>
const bool heap<T,comparator>::empty() const {
    return this->size() == 0;
}

// get the size of the heap
template<typename T, typename comparator>
const size_t heap<T,comparator>::size() const {
    return this->data.size() - 1;
}

// private functions
// affter extracting root value, rebalance the heap
template<typename T, typename comparator>
void heap<T,comparator>::percolateDown(int idx) {
    if( idx > this->size()/2 )
        return;
    int midx = idx;
    if( comp(data[2*idx],data[midx])  )
        midx = 2 * idx;
    if( 2 * idx + 1 <= this->size() && comp(data[2*idx+1],data[midx]) )
        midx = 2 * idx + 1;
    if( midx != idx ) {
        std::swap(data[midx], data[idx]);
        percolateDown(midx);
    }
}

// after insert new element into heap, we need percolateup the element to
// rebalance the heap
template<typename T, typename comparator>
void heap<T,comparator>::percolateUp(int idx) {
    if( idx <= 1 )
        return;
    if( comp(data[idx] , data[idx/2]) ) {
        std::swap(data[idx], data[idx/2]);
        percolateUp(idx/2);
    }
}

#endif

```

以上是priority queue使用heap结构完整实现

```cpp
#include<iostream>
#include "Heap.hpp"
#include<cstddef>
#include<cstdlib>
#include<algorithm>
#include<random>

using namespace std;
void gen_array(int n, vector<int> & data, int base_start = 1, int base_end = 99) {
  srand((unsigned int)time(NULL));
  for(int i = 0; i < n; i++)
    data.push_back( rand() % (base_end - base_start) + base_start );
}

void print_array(vector<int> & data, const string s) {
  cout << s << " : ";
  for(int i = 0; i < data.size(); i++)
    cout << data[i] << " ";
  cout << endl;
}

void heapSort(vector<int> &nums) {
    heap<int> pq(nums);
    nums.resize(0);
    while(!pq.empty() ) {
        nums.push_back(pq.top());
        pq.pop();
    }
}

int main() {
      vector<int> nums;
      srand((unsigned int)time(NULL));
      int n = rand() % 27;
      gen_array(n, nums);
      print_array(nums,"Data");
      heapSort(nums);
      print_array(nums,"Sort");

      // C++ random number generator
      //     // common use case: binding a RNG with a distribution
        default_random_engine e;
        uniform_int_distribution<> d(0, 10);
        function<int()> rnd = std::bind(d, e); // a copy of e is stored in rnd

        nums.push_back(rnd());
        heap<int> pq(nums);
        pq.push(rnd());
        nums.resize(0);
        while(!pq.empty() ) {
            nums.push_back(pq.top());
            pq.pop();
        }
        print_array(nums,"Sort");

      return 0;
}

```


----------------
[^1]: 如果没有特别说明， 本文Heap都是指二叉堆
[1]: https://en.wikipedia.org/wiki/Heap_(data_structure)
